---
title: 用户态和内核态
author: Marlowe
tags:
  - 用户态
  - 内核态
categories: 操作系统
abbrlink: 36887
date: 2021-06-28 15:51:46
---
用户态和内核态相关知识点回顾
<!--more-->

### 1、背景

当我们在写程序是，凡是涉及到IO读写、内存分配等硬件资源的操作时，往往不能直接操作，而是通过一种叫系统调用的过程，让程序陷入到内核态运行，然后内核态的CPU执行有关硬件资源操作指令，得到相关的硬件资源后在返回到用户态继续执行，之间还要进行一系列的数据传输。

假设没有这种内核态和用户态之分，程序随随便便就能访问硬件资源，比如说分配内存，程序能随意的读写所有的内存空间，如果程序员一不小心将不适当的内容写到了不该写的地方，就很可能导致系统崩溃。

**为什么要有用户态和内核态？**

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 – **用户态和内核态**。

### 2、定义

![20210828155938](https://marlowe.oss-cn-beijing.aliyuncs.com/img/20210828155938.png)


系统调用将Linux整个体系分为用户态和内核态（或者说内核空间和用户空间），

1、**内核**：本质上看是一种软件——控制计算机的硬件资源，并提供上层应用程序运行的环境。

* cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

2、**用户态**：上层应用程序的活动空间，只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

* 应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即**系统调用**。

具体说明

![20210828160101](https://marlowe.oss-cn-beijing.aliyuncs.com/img/20210828160101.png)

从这个图上可以更进一步对内核所做的事有一个“全景式”的印象。主要表现为：向下控制硬件资源，向内管理操作系统资源：包括进程的调度和管理、内存的管理、文件系统的管理、设备驱动程序的管理以及网络资源的管理，向上则向应用程序提供系统调用的接口。从整体上来看，整个操作系统分为两层：用户态和内核态，这种分层的架构极大地提高了资源管理的可扩展性和灵活性，而且方便用户对资源的调用和集中式的管理，带来一定的安全性。

### 3、用户态访问内核态资源的方式

用户态的应用程序可以通过三种方式来访问内核态的资源：

* 1）系统调用
* 2）库函数
* 3）Shell脚本

#### 3.1、系统调用

系统调用是操作系统的**最小功能单位**，根据不同的应用场景，不同的Linux发行版本提供的系统调用数量也不尽相同，大致在240-350之间。**系统调用组成了用户态跟内核态交互的基本接口。**

* 例如：用户态想要申请一块20K大小的动态内存，就需要brk系统调用，将数据段指针向下偏移，如果用户态多处申请20K动态内存，同时又释放呢？这个内存的管理就变得非常的复杂。

我们可以把**系统调用看成是一种不能再化简的操作**（类似于原子操作，但是不同概念），有人把它比作一个汉字的一个 **“笔画”** ，而一个 **“汉字”就代表一个上层应用**，因此，有时候如果要**实现一个完整的汉字**（给某个变量分配内存空间），就必须**调用很多的系统调用。**

#### 3.2、库函数

库函数就是屏蔽这些复杂的底层实现细节，减轻程序员的负担，从而更加关注上层的逻辑实现。它对系统调用进行封装，提供简单的基本接口给用户，这样增强了程序的灵活性，当然对于简单的接口，也可以直接使用系统调用访问资源，例如：**open（），write（），read（）** 等等。库函数根据不同的标准也有不同的版本，例如：**glibc库，posix库等。**

接着上面的系统调用继续说：

* 系统调用过多，这势必会加重程序员的负担，良好的程序设计方法是：重视上层的业务逻辑操作，而尽可能避免底层复杂的实现细节。

* **库函数** 正是为了将程序员从复杂的细节中解脱出来而提出的一种有效方法。它实现**对系统调用的封装**，将简单的业务逻辑接口呈现给用户，方便用户调用，从这个角度上看，库函数就像是组成汉字的“偏旁”。
  * 如 **“人”**，对于复杂操作，我们借助于库函数来实现，如 **“仁”**。显然，这样的库函数依据不同的标准也可以有不同的实现版本，如ISO C标准库，POSIX标准库等。

#### 3.3、Shell脚本

Shell是一个**特殊的应用程序**，俗称命令行，本质上是一个命令解释器，它下通系统调用，上通各种应用，通常充当着一种“胶水”的角色，来连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。

![20210828160609](https://marlowe.oss-cn-beijing.aliyuncs.com/img/20210828160609.png)

* Shell 就是一个“中间商”，它在用户和内核之间“倒卖”数据，只是用户不知道罢了。
* Shell 本身并不是内核的一部分，它只是站在内核的基础上编写的一个应用程序，它和 QQ、迅雷、Firefox等其它软件没有什么区别。然而Shell 也有着它的特殊性，就是开机立马启动，并呈现在用户面前；用户通过 Shell 来使用Linux，不启动 Shell 的话，用户就没办法使用 Linux。

### 4、用户态到内核态怎样切换？

* Linux操作系统中主要采用了**0和3两个特权级**，分别对应的就是**内核态和用户态。**
* 运行于用户态的进程可以执行的操作和访问的资源都会受到极大的限制，而运行在内核态的进程则可以执行任何操作并且在资源的使用上没有限制。
* 很多程序开始时运行于用户态，但在执行的过程中，一些操作**需要在内核权限下才能执行**，这就涉及到一个从**用户态切换到内核态的过程。**
  * 比如C函数库中的内存分配函数malloc()，它具体是使用sbrk()系统调用来分配内存，当malloc调用sbrk()的时候就涉及一次从用户态到内核态的切换，
  * 类似的函数还有printf()，调用的是wirte()系统调用来输出字符串，等等。

![20210828160824](https://marlowe.oss-cn-beijing.aliyuncs.com/img/20210828160824.png)

#### 从用户态到内核态切换可以通过三种方式

* **系统调用**：其实系统调用本身就是中断，但是软件中断，跟硬中断不同。
* **异常**： 当CPU正在执行运行在用户态的程序时，突然发生某些预先不可知的异常事件，这个时候就会触发从当前用户态执行的进程转向内核态执行相关的异常事件，典型的如**缺页异常**。
* **外设中断（硬中断）**：当外围设备完成用户的请求操作后，会像CPU发出中断信号，此时，CPU就会暂停执行下一条即将要执行的指令，转而去执行中断信号对应的处理程序，如果先前执行的指令是在用户态下，则自然就发生从用户态到内核态的转换。

#### 注意

* **系统调用的本质其实也是中断**，相对于外围设备的硬中断，这种中断称为**软中断**，这是操作系统为用户特别开放的一种中断，如**Linux int 80h**中断。
* 从触发方式和效果上来看，这三种切换方式是完全一样的，都相当于是执行了一个中断响应的过程。但是从触发的对象来看，**系统调用**是进程**主动请求切换**的，而**异常和硬中断**则是**被动的**。


### 5、一些问题

#### Shell 是如何连接用户和内核的？

shell 能够接收用户输入的命令，并对命令进行处理，处理完毕后再将结果反馈给用户，比如输出到显示器、写入到文件等，这就是大部分读者对 Shell 的认知。

你看，我一直都在使用 Shell，哪有使用内核哦？我也没有看到 Shell 将我和内核连接起来呀？

其实，Shell 程序本身的功能是很弱的，比如文件操作、输入输出、进程管理等都得依赖内核。我们运行一个命令，大部分情况下 Shell 都会去调用内核暴露出来的接口，这就是在使用内核，只是这个过程被 Shell 隐藏了起来，它自己在背后默默进行，我们看不到而已。

接口其实就是一个一个的函数，使用内核就是调用这些函数。这就是使用内核的全部内容了吗？嗯，是的！除了函数，你没有别的途径使用内核。

### 6、参考

[Linux常问面试问题之——用户态与内核态、用户态访问内核态资源的方式、用户态到内核态的切换](https://blog.csdn.net/JMW1407/article/details/107901155)
